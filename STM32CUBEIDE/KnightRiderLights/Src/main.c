/**
 ******************************************************************************
 * @file    main.c
 * @author  Auto-generated by STM32CubeIDE
 * @version V1.0
 * @brief   Default main function.
 ******************************************************************************
 */



#include <stdio.h>
#include <stdint.h>
#include "uart_driver.h"
#include "delay.h"

#define F_CPU 16000000UL
#define PERIPH_BASE 0x40000000

#define RCC_BASE (PERIPH_BASE + 0x23800)
#define AHB1ENR (RCC_BASE + 0x30)

#define GPIO_PORT_SPACING 0x400
#define GPIO_BASE (PERIPH_BASE + 0x20000)

#define LED_NUCLEO_GPIO_PORT 1 // Port B
#define LED_NUCLEO_GPIO_PIN 5
#define LED_NUCLEO_GPIO_PORT_BASE (GPIO_BASE + LED_NUCLEO_GPIO_PORT * GPIO_PORT_SPACING)

#define GPIO_ODR (LED_NUCLEO_GPIO_PORT_BASE + 0x14)
#define GPIO_MODER (LED_NUCLEO_GPIO_PORT_BASE + 0x00)

//prototype
void light_LED(int);

int main(void){
	//enable clock register
	uint32_t *rcc = (uint32_t*) AHB1ENR;
	*rcc = (*rcc|(1<<LED_NUCLEO_GPIO_PORT));
	int ledPin = LED_NUCLEO_GPIO_PIN;

	//gpio mode output
	while(ledPin <= 15) {
		uint32_t *gpioMode = (uint32_t*) GPIO_MODER;
		*gpioMode = (*gpioMode|(0b01<<(ledPin*2)));
		ledPin++;
	}

	int bit = 1;
	int up = 10; // number of times bit shifts up
	int down = 0; // number of times bit shifts down

	//infinite loop
	//bad practice I'm sure
	while(1 != 0){
		int shiftbit = 0;
		while(shiftbit <= up){
			delay_ms(100000);
			light_LED(bit<<shiftbit);
			shiftbit++;
		}
		shiftbit--;
		while(shiftbit >= down) {
			delay_ms(100000);
			light_LED(bit<<shiftbit);
			shiftbit--;
		}
	}
	return 0;
}

void light_LED(int number) {

	//setting LED
	int gpioPin = LED_NUCLEO_GPIO_PIN;
	uint32_t shift = 0; //shift bits
	uint32_t *gpioLED = (uint32_t*) GPIO_ODR;
	while(shift <= 10) {
		if ((number&(1<<shift)) != 0) {
			*gpioLED = (*gpioLED|(1<<gpioPin));
		} else {
			*gpioLED = (*gpioLED&(~(1<<gpioPin)));
		}
		shift++;
		gpioPin++;
	}
}


/*
 * delay.c
 *
 *  Created on: Dec 10, 2019
 *      Author: yanga
 */

/*
#include <stdint.h>

#define STK_CTRL 0xE000E010;
#define STK_LOAD 0xE000E014;
#define STK_VAL 0xE000E018;
#define COUNTFLAG (0b01<<16)


void delay_ms(int theDelay)
{
	//insert reload value
	uint32_t *reload = (uint32_t*) STK_LOAD; //reload value
	*reload = theDelay;

	//enable stk
	uint32_t *countenable = (uint32_t*) STK_CTRL;
	int enable = 1;
	*countenable = (*countenable|enable);

	volatile uint32_t *countflag = (uint32_t*) STK_CTRL; //countflag
	while(!(*countflag&COUNTFLAG)) {
	}
}


/*
 * delay.h
 *
 *  Created on: Dec 10, 2019
 *      Author: yanga
 */

/*


#ifndef DELAY_H_
#define DELAY_H_

void delay_ms(int);

#endif /* DELAY_H_ */


/**
 ******************************************************************************
 * @file    main.c
 * @author  Auto-generated by STM32CubeIDE
 * @version V1.0
 * @brief   CE 4951 Network Interface Node
 ******************************************************************************
 */
#include <stdio.h>
#include <stdlib.h>
#include "stm32f446xx.h"
#include "uart_driver.h"
#include "delay.h"
#include "gpio.h"
#include "nvic.h"
#include "systick.h"
#include "math.h"

#define DELAY_TIME (double) 0.00111f
#define TIMEOUT_RELOAD (uint32_t) ((F_CPU * DELAY_TIME) - 1)

#define NVIC_ISER1 (uint32_t*) 0xE000E104

// array to store manchester encoding; maximum of 5 characters each with 16 binary digits
int manchester[5][16];
int receiveManchester[30][16];
int binary[5][8];
int bit, manchesterBit, count;
int n;
int receiveManchester[30][16];
int receiveBinary[30][8];
char input[480];
int count = 0;
int manCount = 0;
int k = 0;
int l = 0;

// State machine state
enum {
	BUSY = 0, IDLE = 1, COLLISION = 2
} STATE;

// LED array color codes
const uint16_t GREEN = 0x0004U;
const uint16_t AMBER = 0x0002U;
const uint16_t RED = 0x0001U;

/*
 * NIC Initializer
 *
 * Set up state variable, GPIO clock,
 * EXTI, IRQs, and delay time
 */
void NIC_INIT() {
	// Initialize program control variables
	STATE = IDLE;
	// Enable GPIO clock for data line (NOTE: data line on PC10 for now)
	gpio_init(GPIOC, 10, INPUT);
	gpio_init(GPIOC, 11, OUTPUT);
	gpio_init(GPIOC, 12, INPUT);
	//gpio_write(GPIOC, 11, HIGH);
//	GPIOC->PUPDR |= 0x00100000U;
	// Configure EXTI to trigger interrupt on all PC10 edges
	SYSCFG->EXTICR3 |= 0x00000200U;
	EXTI->IMR |= 0x00000400U;
	EXTI->RTSR |= 0x00000400U;
	EXTI->FTSR |= 0x00000400U;
	// Enable interrupt request for EXTI
	NVIC_EnableIRQ(EXTI15_10_IRQ);

	*(NVIC_ISER1 ) |= 1 << 8;
	// Enable SysTick
	SYSTICK->LOAD = TIMEOUT_RELOAD;
	SYSTICK->CTRL |= 0x00000007U;
}

/*
 * LED Initializer
 *
 * Enables the clock, clears the mode register, and sets the mode register to output for each LED pin
 */
void LIGHT_LED_INIT(void) {
	// enable the clock for port B
	RCC->AHB1ENR |= RCC_AHB1ENR_GPIOBEN;

	// set the mode register
	// mask to clear out PB5-PB10, PB12-PB15: 00C0 03FF
	GPIOB->MODER &= 0x00C003FFU;

	// mask to set PB5-PB10, PB12-PB15: 5515 5400
	GPIOB->MODER |= 0x55155400U;
}

/*
 * Turn On LED
 *
 * Pass in color code
 * lights are on PB5-PB10, PB12-PB15
 */
void LIGHT_LED(unsigned int number) {
	// split the number into halves to avoid pin 11 by &ing them into two different numbers
	unsigned int upper_bits = number & 0x03C0U;
	unsigned int lower_bits = number & 0x003FU;
	unsigned int bitmask = (upper_bits << 6U | lower_bits << 5U);
	GPIOB->ODR &= 0xFFFF081FU;
	// turn light on
	GPIOB->ODR |= bitmask;
}

/*
 * Convert a string to manchester encoding
 *
 * Pass in string from user
 * Maximum of five characters
 *
 * Stores encoded string in manchester int array, 16 bits per letter
 */
void STRING_TO_MANCHESTER(char input[5]) {

// print ASCII codes for each character
	printf("ASCII Encoding:\n");
	for (int i = 0; i < 5; i++) {
		n = input[i];
		printf("%d\n", input[i]);
		// convert each ASCII value to binary
		for (int j = 0; n > 0; j++) {
			binary[i][7 - j] = n % 2;
			n = n / 2;
		}
	}

	// print binary encodings for each character
	printf("Binary Encoding:\n");
	for (int i = 0; i < 5; i++) {
		count = 0;
		for (int j = 0; j < 8; j++) {
			bit = binary[i][j];
			printf("%d", bit);
			// convert binary to manchester encoding
			// store in manchester int array
			if (bit == 0) {
				manchester[i][count] = 1;
				manchester[i][count + 1] = 0;
			} else if (bit == 1) {
				manchester[i][count] = 0;
				manchester[i][count + 1] = 1;
			}
			count += 2;
		}
		printf("\n");
	}

	// print manchester encodings
	printf("Manchester Encoding:\n");
	for (int i = 0; i < 5; i++) {
		for (int j = 0; j < 16; j++) {
			manchesterBit = manchester[i][j];
			printf("%d", manchesterBit);
		}
		printf("\n");
	}
}
void RECEIVE_MANCHESTER() {
	//printf("Manchester Encoding: \n");

	if (((GPIOC->IDR >> 12) & 0x0001U) == 0x0U) {
		receiveManchester[k][l] = 0;
		if (l % 2 == 0) {
			receiveBinary[k][l / 2] = 1;
		}
	} else if (((GPIOC->IDR >> 12) & 0x0001U) == 0x1U) {
		receiveManchester[k][l] = 1;
		if (l % 2 == 0) {
			receiveBinary[k][l / 2] = 0;
		}
	}
	printf("%d", receiveManchester[k][l]);
	k++;
	if (k == 30) {
		k = 0;
	}
	l++;
	if (l == 16) {
		l = 0;
	}
	count++;
	//delay_us(500);
	//}
	//}

	if (manCount == 32) {
		// print the binary encoding
		printf("\nBinary Encoding: \n");
		for (int i = 0; i < count / 16; i++) {
			for (int j = 0; j < 8; j++) {
				printf("%d", receiveBinary[i][j]);
			}
		}
		printf("\n");

		// convert the binary encodings to decimal and print them as hexadecimal ASCII characters
		printf("ASCII Characters: \n");
		for (int i = 0; i < count / 16; i++) {
			int ASCII = 0;
			for (int j = 0; j < 8; j++) {
				if (7 - j != 0) {
					ASCII += receiveBinary[i][j] << (7 - j);
				} else {
					ASCII += receiveBinary[i][j];
				}
			}
			printf("%c", ASCII);
			manCount = 0;
			//delay_ms(5000);
		}
	}

	manCount++;
	//delay_us(500);

}
/*
 * Transmit manchester encoding
 *
 * Writes to output pin from previously encoded
 * manchester int array
 */
void TRANSMIT_MANCHESTER() {
	double rand_delay_ms;
	time_t t;

	// initialize random number generation
	//srand((unsigned) time(&t));

	// wait for the channel monitor to be idle
//	while (STATE != IDLE) {
//	}

	// begin transmission loop,
	// 16 bits/character
	// 5 characters/word
	for (int i = 0; i < 5; i++) {
		for (int j = 0; j < 16; j++) {
			// check if the channel monitor is in a collision state;
			// wait random time if true
			if (STATE == COLLISION) {
				// wait random time <999 milliseconds
				// generate random double from 0 to 999
				rand_delay_ms = (rand() % 1000);
				delay_ms(rand_delay_ms);
			}
			// wait for bus to be idle if needed
//			while (STATE != IDLE) {
//			}
			// write bit to output pin
			//
			delay_us(500);
			gpio_write(GPIOC, 11, manchester[i][j]);
			printf("manchester test : %d\n", manchester[i][j]);
			//RECEIVE_MANCHESTER();
			//delay_ms(1000);
		}
	}
}

// main
int main(void) {
// Initialize serial adapter
	init_usart2(57600, F_CPU);
	printf("Hello World!!\n");

// Char array for input string
	char input[5];

// Initialize LED array
	LIGHT_LED_INIT();

// Initialize NIC
	NIC_INIT();

// Request user input
	printf("Enter a string less than five characters\n");
	scanf("%s", input);
// Encode string as ASCII manchester binary in int array
	STRING_TO_MANCHESTER(input);

// Main infinite loop
	while (1) {
		// Write encoded string to output GPIO pin
		//TRANSMIT_MANCHESTER();
		//RECEIVE_MANCHESTER();
		switch (STATE) {
		case IDLE:
			// first LEDs will be "green" for idle
			LIGHT_LED(GREEN);
			break;
		case BUSY:
			// middle LEDs will be "yellow" for busy
			LIGHT_LED(AMBER);
			break;
		case COLLISION:
			// end LEDs will be "red" for collision
			LIGHT_LED(RED);
			break;
		}
	}
	return 0;
}

//Interrupt Service Routines

/*
 * Input Capture Interrupt Service Routine
 *
 * ISR runs every clock edge.
 * Sets state to BUSY.
 * Pauses timeout clock (SysTick) during ISR,
 * then resets it.
 */
void EXTI15_10_IRQHandler(void) {
// Stop timeout counter
	SYSTICK->CTRL &= ~(0x1U);
// Clear interrupt flag
	EXTI->PR |= 0x00000400U;
// Set state machine to busy state
	STATE = BUSY;
// Reset timeout counter
	SYSTICK->VAL = 0;
	SYSTICK->LOAD = TIMEOUT_RELOAD;
	SYSTICK->CTRL |= 0x1U;
	RECEIVE_MANCHESTER();
}

/*
 * Timer Interrupt Service Routine
 *
 * ISR runs after extended logic level,
 * either a collision if logic-0 or idle if logic-1.
 * Function will update state after timeout interrupt.
 */
void SysTick_Handler(void) {
// Stop timer
	SYSTICK->CTRL &= ~(0x1U);
// Check for collision/idle
//	if(gpio_read(GPIOC, 10) == LOW){
	if (((GPIOC->IDR >> 10) & 0x0001U) == 0x0U) {
		STATE = COLLISION;
	}
//	else if(gpio_read(GPIOC, 10) == HIGH){
	else if (((GPIOC->IDR >> 10) & 0x0001U) == 0x1U) {
		STATE = IDLE;
	}
// Start Timer
//	SYSTICK->CTRL |= (0x1U);
}

